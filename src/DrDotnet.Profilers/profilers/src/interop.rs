// Autogenerated by FFIDJI

#![allow(unused_imports)]
#![allow(dead_code)]
#![allow(non_camel_case_types)]

extern crate libc;
// To get strings, use CString. Example:
// let c_str: &CStr = unsafe { CStr::from_ptr(c_buf) };
use std::ffi::CStr; 

use std::alloc::GlobalAlloc;
use std::alloc::System;
use std::alloc::Layout;

use u16 as char16;
use i8 as int8;
use u8 as uint8;
use i16 as int16;
use u16 as uint16;
use i32 as int32;
use u32 as uint32;
use i64 as int64;
use u64 as uint64;
use f32 as float32;
use f64 as float64;

use crate::get_profiler_infos;
use crate::profilers::ProfilerData;

#[no_mangle]
pub extern "C" fn Alloc_FFI(length :int32) -> *mut libc::c_void
{ 
    unsafe
    { 
        return libc::malloc(length as usize);
    } 
} 

#[no_mangle]
pub extern "C" fn Free_FFI(ptr: *mut libc::c_void, length: int32)
{ 
    unsafe
    { 
        libc::free(ptr);
    } 
} 

pub struct Profiler
{ 
    name: string,
    description: string,
    guid: string,
    is_released: bool,
} 

#[repr(C)]
pub struct Profilers
{ 
    profilers_ptr: *const Profiler,
    profilers_len: int32,
} 

pub struct string
{ 
    utf8bytes_ptr: *const uint8,
    utf8bytes_len: int32,
} 

unsafe fn get_string(str: String) -> string {
    let s = std::ffi::CString::new(str).unwrap();
    let p = s.as_ptr();
    std::mem::forget(s);
    return string {
        utf8bytes_ptr: p as *mut uint8,
        utf8bytes_len: 0,
    }
}

#[no_mangle]
pub extern "C" fn GetAvailableProfilers() -> Profilers
{
    unsafe {
        let profiler_infos = get_profiler_infos();
        let len = profiler_infos.len() as usize;

        let ptr = libc::malloc( len * std::mem::size_of::<Profiler>()) as *mut Profiler;

        for n in 0..len {

            let mut p = ptr.offset(n as isize);

            (*p).name = get_string(profiler_infos[n].name.to_owned());
            (*p).description = get_string(profiler_infos[n].description.to_owned());
            (*p).guid = get_string(profiler_infos[n].profiler_id.to_string());
            (*p).is_released = profiler_infos[n].is_released;
        }

        return Profilers {
            profilers_ptr: ptr,
            profilers_len: len as i32,
        }
    }
} 